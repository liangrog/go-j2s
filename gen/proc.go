// Generating Go code from json files
package gen

import (
	"encoding/json"
	"fmt"
	"github.com/liangrog/go-j2s/conf"
	"go/format"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"reflect"
	"sort"
	"strings"
	"sync"
	"time"
)

// Generated Go file format
const fileLayout = `// Code generated by go-j2s at %s
package %s

%s
`

// Process passed in arguments then create codes, write them
// to the file specified in the arguments
func Proc() error {
	// Get cmd args and validate them
	a := conf.Parse()
	if err := a.Validate(); err != nil {
		return err
	}

	codes, err := genGoCodes(a)
	if err != nil {
		return err
	}

	t := time.Now()
	Must(writeGoCode(a.GetOutFile(), fileLayout, t.Format(time.RFC3339), a.PkgName, codes))

	return nil
}

// Formate code string and write them into file
func writeGoCode(file string, layout string, args ...interface{}) error {
	src, err := GoFmt(fmt.Sprintf(layout, args...))
	if err != nil {
		return err
	}

	return ioutil.WriteFile(file, []byte(src), 0664)
}

// Generate go codes by search all the json files
func genGoCodes(a *conf.Args) (string, error) {
	files, err := findJsonFiles(a)
	if err != nil {
		return "", err
	}

	if len(files) == 0 {
		return "", fmt.Errorf("No json files found in the given directory \"%s\". You may try using \"-r\" option", a.InPath)
	}

	// Concurrently process each found
	// json file
	r := make(chan string, len(files))
	go func() {
		var wg sync.WaitGroup
		for _, f := range files {
			wg.Add(1)
			go func(fp string) {
				defer wg.Done()
				r <- fmt.Sprintln(unmarshal(fp))
			}(f)
		}

		// Wait for all go routine complete
		// before we close the channel
		wg.Wait()
		close(r)
	}()

	// Fetch all outcomes from channel
	var codes string
	for res := range r {
		codes += fmt.Sprintf("%s\n", res)
	}

	return codes, nil
}

// Unmarshal json file into go code string
func unmarshal(fp string) string {
	// Use file name as type name
	typeName := CamelCase(strings.TrimRight(path.Base(fp), ".json"))

	// Get json object from file
	var d interface{}
	raw, _ := ioutil.ReadFile(fp)
	Must(json.Unmarshal(raw, &d))

	return fmt.Sprintf(
		"%s %s",
		fmt.Sprintf("type %s", typeName),
		walkJson(d, ""),
	)
}

// Recursively walk through json object, determine
// each types, return all into a string
func walkJson(v interface{}, key string) string {
	var res, subRes string

	// Camel case the key
	if key != "" {
		res = CamelCase(key)
	}

	// Reflect value and type
	rv := reflect.ValueOf(v)
	rt := reflect.TypeOf(v)

	switch getKind(rt) {
	case reflect.Slice:
		// Find out element type
		switch getKind(rt.Elem()) {
		// If the element is map, continue into the map
		case reflect.Map:
			subRes = walkJson(rv.Index(0).Interface(), key)
		// If the element is null or other interface
		case reflect.Interface:
			subRes = "interface{}"
			// If it's not an empty, continue into the element
			if rt != nil && rv.Len() > 0 {
				subRes = walkJson(rv.Index(0).Interface(), "")
			}
		// All other types, simply get the type string
		default:
			subRes = rt.Elem().Kind().String()
		}
		res = fmt.Sprintf("%s []%s", res, subRes)
	case reflect.Map:
		// Loop through the map continue into each leaf
		for _, kv := range rv.MapKeys() {
			subRes += walkJson(rv.MapIndex(kv).Interface(), kv.Interface().(string))
		}
		res = fmt.Sprintf("%s struct {%s}", res, subRes)
	default:
		var typ string
		// If value is null use interface type
		if rt == nil {
			typ = "interface{}"
		} else {
			typ = getKind(rt).String()
		}
		res = fmt.Sprintf("%s %s", res, typ)
	}

	// Add field tags
	if key != "" {
		res = fmt.Sprintf("%s `json:\"%s\"`\n", res, key)
	}
	return res
}

// Return kind of the type
func getKind(t reflect.Type) reflect.Kind {
	if t == nil {
		return reflect.Interface
	}

	return t.Kind()
}

// Search all json files according to the arguments
func findJsonFiles(a *conf.Args) ([]string, error) {
	var fl []string

	// Anonymous function to append found json file to result
	add := func(path string, info os.FileInfo) {
		// Exclude pathes specified
		if len(a.ExclPath) > 0 {
			for _, ep := range a.ExclPath {
				if strings.Contains(path, ep) {
					return
				}
			}
		}

		// Exclude files that's not specified
		if len(a.InFile) > 0 {
			for _, inf := range a.InFile {
				if !strings.Contains(path, inf) {
					return
				}
			}
		}

		if !info.IsDir() && filepath.Ext(info.Name()) == ".json" {
			fl = append(fl, path)
		}
	}

	// If it's a recursive search, we'll walk
	if a.Recursive {
		walk := func(path string, info os.FileInfo, err error) error {
			if err == nil && !info.IsDir() {
				add(path, info)
			}

			return nil
		}

		filepath.Walk(a.InPath, walk)
	} else {
		items, err := ioutil.ReadDir(a.InPath)
		if err != nil {
			return fl, err
		}
		for _, info := range items {
			p := filepath.Join(a.InPath, info.Name())
			add(p, info)
		}
	}

	sort.Strings(fl)

	return fl, nil
}

// Panic if error
func Must(err error) {
	if err != nil {
		panic(err)
	}
}

// Convert string to camel case
func CamelCase(s string) (cc string) {
	// Strings to remove
	toRemove := map[string]string{
		"-": "-",
		"_": "_",
	}

	nextUpper := false
	for k, v := range s {
		vv := string(v)
		if k == 0 {
			cc = strings.ToUpper(vv)
			continue
		}

		if _, ok := toRemove[vv]; ok {
			nextUpper = true
			continue
		} else {
			if nextUpper {
				cc += strings.ToUpper(vv)
			} else {
				cc += vv
			}

			nextUpper = false
		}
	}

	return
}

// Formatting go codes
func GoFmt(s string) (string, error) {
	formatted, err := format.Source([]byte(s))
	return string(formatted), err
}
